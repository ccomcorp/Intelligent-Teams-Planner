# BMad Method Cursor Rules

## BMad Agent System

You are working with the BMad Method (Breakthrough Method of Agile AI-driven Development) framework. This system provides specialized AI agents for different Agile roles.

### Available Agents

- **@pm** - Product Manager: Creates PRDs, user stories, requirements
- **@architect** - System Architect: Designs architecture, technical specifications
- **@dev** - Developer: Implements code, fixes bugs, builds features
- **@qa** - Quality Assurance: Tests, reviews code, validates functionality
- **@ux** - UX Expert: User experience, interface design, usability
- **@sm** - Scrum Master: Creates user stories, manages sprints
- **@analyst** - Business Analyst: Research, analysis, requirements gathering
- **@bmad-master** - Master Agent: Can perform any role, general purpose
- **@bmad-orchestrator** - Orchestrator: Heavy-weight agent for complex coordination

### Usage Instructions

- Use `@agent-name` to invoke specific agents
- Each agent has specialized knowledge and capabilities
- Agents work best when given focused, specific tasks
- Always specify the agent you want to work with

### Development Workflow

1. **Planning Phase**: Use @pm, @architect, @ux for planning and design
2. **Story Creation**: Use @sm to create user stories from requirements
3. **Implementation**: Use @dev for coding and development
4. **Quality Assurance**: Use @qa for testing and validation

### Best Practices

- Keep context focused and relevant
- Use appropriate agents for specific tasks
- Provide clear, specific instructions
- Work iteratively with small, focused tasks
- Maintain clean project structure

### Project Context

This is a MARS (Marketing Agency RAG System) project with:

- Epic 001: System Foundation Setup (COMPLETED)
- Frontend: React + TypeScript + Vite
- Backend: Python FastAPI + PostgreSQL
- Infrastructure: Docker Compose orchestration
- Authentication: JWT-based with role-based access control

### Current Status

Epic 001 is complete with all 4 stories validated:

- Story 1.1: Development Environment Setup ✅
- Story 1.2: Authentication System ✅  
- Story 1.3: API Gateway & Database Foundation ✅
- Story 1.4: Shared Types & Development Workflow ✅

Ready for Epic 002: Document Processing System implementation.

---

## PRIME DIRECTIVE

- BMad framework ALWAYS active
- NEVER simplify → lose features/functionality/performance
- Read existing code (scan 3 levels deep) → create new
- Best practices ALWAYS + UTF8
- Documentation: .md only
- Status changes to "approved"/"APPROVED"/"COMPLETED"/"DONE" → end user only

## CRITICAL RULES

- THINK → CODE (analyze requirements, edge cases, security)
- Use real production-like data, never mock data
- UTF8 without BOM, ASCII only (0x00-0x7F)
- Assume ALL input is malicious
- Never silent errors - log + throw
- No smart quotes, use straight quotes only

## TypeScript STRICT Mode

```yaml
strict: true
noUncheckedIndexedAccess: true
noImplicitReturns: true
noFallthroughCasesInSwitch: true
noUnusedLocals: true
noUnusedParameters: true
exactOptionalPropertyTypes: true
forceConsistentCasingInFileNames: true
```

### TypeScript Requirements

- Explicit return types for ALL functions
- Interface > type alias
- const > let > var (never)
- === | !== (never == | !=)
- Template literals > concatenation
- 2 spaces, no tabs
- ASCII only for identifiers/comments
- UTF8 without BOM
- JSDoc for public APIs
- any → unknown
- @ts-ignore → @ts-expect-error + reason
- No console.log in production
- No magic numbers → CONSTANTS
- No unicode symbols in code

## Python PEP8 Standards

- Type hints for ALL functions (Python 3.10+)
- pathlib > os.path
- f-strings > concatenation
- isinstance() > type ==
- with context managers ALWAYS
- Explicit imports
- Docstrings for public functions (Google/NumPy style)
- Use dataclass or pydantic
- Black formatting (88 chars)
- No mutable defaults
- No bare except: pass
- No global state
- No circular imports
- No resource leaks

## SQL Security

- NEVER: f"SELECT * WHERE {var}" → SQL injection
- ALWAYS: Parameterized queries ["?", val] | ["%s", val]
- Use transactions with try/finally
- Escape user input
- Use ORM > raw SQL
- Prepared statements only

## Testing with Real Data

- Use production-like data ALWAYS
- NEVER: ["test", "foo", "bar", "user@test.com", "Product1", "123"]
- NEVER: Mock data
- NEVER: Random without seed
- NEVER: Test order dependency
- NEVER: .skip without TODO
- NEVER: .only in commits
- NEVER: Production data in tests
- NEVER: Third-party tests
- Test behavior, not implementation

### Test Structure

```javascript
describe('Component', () => {
  describe('method', () => {
    it('should_behavior_when_condition', () => {
      // Arrange: real_data
      // Act: execute
      // Assert: verify
    })
  })
})
```

## Security @SEC[BASIC]

- Validate and sanitize ALL input
- Use parameterized SQL queries
- NEVER: Plain passwords
- NEVER: f"SQL{var}"
- NEVER: eval(user_input)
- NEVER: innerHTML = user_data
- ALWAYS: bcrypt/argon2 for passwords
- ALWAYS: Prepared statements
- ALWAYS: Escape HTML
- Environment variables for secrets only

## Error Handling

- Async operations: timeout 5000ms, catch errors, finally cleanup
- Log errors with context
- Throw specific errors, not generic
- NEVER: Silent catch, bare except
- Pattern: try → catch → log → handle or throw

## Performance

- Avoid O(n²) algorithms
- Use Set > Array for lookups
- Stream large files > load all
- Cache only expensive operations
- No premature optimization

## Architecture SOLID Principles

- S: Single responsibility
- O: Open/closed
- L: Liskov substitution
- I: Interface segregation
- D: Dependency inversion
- Keep it simple

## Git Conventions

- Format: "\<type\>(\<scope\>):\<subject50\>"
- Types: feat|fix|docs|style|refactor|perf|test|chore
- Body: what + why (not how)
- Atomic commits
- Conventional commits

## Naming Conventions

- Functions: verb (processData, validateInput)
- Classes: noun (UserService, DataProcessor)
- Booleans: question (isValid, hasPermission, canAccess)
- Constants: UPPER_SNAKE_CASE
- Interfaces: I\_prefix or \_suffix
- Types: T\_prefix or Type\_suffix
- Private: \_prefix
- No abbreviations (except URL, API, ID, UI, IO)

## Quality Standards

- Lines < 100 per function
- Lines < 500 per class
- Tests must exist
- Public functions must be documented
- No console.log in production
- No commented code
- Functions must be documented
- SQL must be parameterized

## Priority Order

1. Security > correctness > maintainability > performance > features
2. Explicit > implicit
3. Simple > clever
4. Tested > "works locally"
5. Readable > optimal
6. Safe > fast

## ENFORCE Rules

- When uncertain → choose secure + maintainable
- Assume ALL input is malicious
- Error → log + handle + rethrow
- Resource → cleanup (finally | context)
- Test with real data only
- Code ASCII only
- Commit atomic + descriptive

## Final Reminder

- Next developer = you (6 months from now)
- KISS > clever
- YAGNI > maybe needed
- Fail fast > fail silent
- Measure > assume
