# Story 3.3: Infrastructure as Code

## Status
Draft

## Story

**As an** infrastructure engineer,
**I want** complete infrastructure defined and provisioned through code,
**so that** environments are consistent, reproducible, and can be managed through version control.

## Acceptance Criteria

1. **Terraform Infrastructure**: Complete infrastructure provisioned using Terraform
2. **Helm Chart Management**: Application deployment managed through Helm charts
3. **Environment Configuration**: Environment-specific configuration management
4. **State Management**: Secure and reliable Terraform state management
5. **Resource Optimization**: Automated resource optimization and cost control
6. **Compliance Automation**: Automated compliance checking and governance
7. **Drift Detection**: Automated detection and correction of infrastructure drift
8. **Documentation Generation**: Automated infrastructure documentation generation

## Tasks / Subtasks

- [ ] Task 1: Implement Terraform Infrastructure (AC: 1)
  - [ ] Create Terraform modules for cloud infrastructure
  - [ ] Implement network, security, and compute resources
  - [ ] Setup Kubernetes cluster provisioning
  - [ ] Create database and storage infrastructure
  - [ ] Implement monitoring and logging infrastructure

- [ ] Task 2: Develop Helm Chart Management (AC: 2)
  - [ ] Create Helm charts for all application components
  - [ ] Implement chart versioning and release management
  - [ ] Setup Helm repository and artifact management
  - [ ] Create chart testing and validation
  - [ ] Implement chart dependency management

- [ ] Task 3: Setup Environment Configuration Management (AC: 3)
  - [ ] Create environment-specific Terraform configurations
  - [ ] Implement configuration templating and validation
  - [ ] Setup secrets management with external providers
  - [ ] Create environment promotion workflows
  - [ ] Implement configuration drift monitoring

- [ ] Task 4: Implement Secure State Management (AC: 4)
  - [ ] Setup remote Terraform state backend
  - [ ] Implement state locking and encryption
  - [ ] Create state backup and recovery procedures
  - [ ] Setup state access controls and auditing
  - [ ] Implement state consistency validation

- [ ] Task 5: Build Resource Optimization System (AC: 5)
  - [ ] Implement automated resource right-sizing
  - [ ] Create cost monitoring and alerting
  - [ ] Setup resource utilization optimization
  - [ ] Implement automated scaling policies
  - [ ] Create cost allocation and chargeback reporting

- [ ] Task 6: Automate Compliance and Governance (AC: 6)
  - [ ] Implement policy-as-code with Open Policy Agent
  - [ ] Create compliance scanning and reporting
  - [ ] Setup security policy enforcement
  - [ ] Implement governance workflows
  - [ ] Create compliance audit trails

- [ ] Task 7: Setup Drift Detection and Correction (AC: 7)
  - [ ] Implement automated drift detection
  - [ ] Create drift correction workflows
  - [ ] Setup drift alerting and notifications
  - [ ] Implement configuration reconciliation
  - [ ] Create drift prevention policies

- [ ] Task 8: Automate Documentation Generation (AC: 8)
  - [ ] Generate infrastructure documentation from code
  - [ ] Create architecture diagrams automatically
  - [ ] Implement runbook generation
  - [ ] Setup documentation versioning
  - [ ] Create interactive infrastructure maps

## Dev Notes

### Relevant Source Tree Information

**Infrastructure as Code Structure:**
```
terraform/
├── modules/
│   ├── networking/
│   │   ├── main.tf               # NEW FILE - VPC and networking
│   │   ├── variables.tf          # NEW FILE - Input variables
│   │   ├── outputs.tf            # NEW FILE - Output values
│   │   └── versions.tf           # NEW FILE - Provider versions
│   ├── compute/
│   │   ├── kubernetes.tf         # NEW FILE - Kubernetes cluster
│   │   ├── load-balancer.tf      # NEW FILE - Load balancers
│   │   ├── auto-scaling.tf       # NEW FILE - Auto-scaling groups
│   │   └── security-groups.tf    # NEW FILE - Security configurations
│   ├── storage/
│   │   ├── postgresql.tf         # NEW FILE - Database infrastructure
│   │   ├── redis.tf              # NEW FILE - Redis cluster
│   │   ├── object-storage.tf     # NEW FILE - Object storage
│   │   └── persistent-volumes.tf # NEW FILE - Kubernetes storage
│   ├── monitoring/
│   │   ├── prometheus.tf         # NEW FILE - Monitoring stack
│   │   ├── grafana.tf            # NEW FILE - Dashboard infrastructure
│   │   ├── alerting.tf           # NEW FILE - Alert infrastructure
│   │   └── logging.tf            # NEW FILE - Logging infrastructure
│   └── security/
│       ├── iam.tf                # NEW FILE - Identity and access
│       ├── certificates.tf       # NEW FILE - SSL certificates
│       ├── secrets.tf            # NEW FILE - Secrets management
│       └── policies.tf           # NEW FILE - Security policies
├── environments/
│   ├── development/
│   │   ├── main.tf               # NEW FILE - Dev environment
│   │   ├── terraform.tfvars      # NEW FILE - Dev variables
│   │   └── backend.tf            # NEW FILE - State backend
│   ├── staging/
│   │   ├── main.tf               # NEW FILE - Staging environment
│   │   ├── terraform.tfvars      # NEW FILE - Staging variables
│   │   └── backend.tf            # NEW FILE - State backend
│   └── production/
│       ├── main.tf               # NEW FILE - Production environment
│       ├── terraform.tfvars      # NEW FILE - Production variables
│       └── backend.tf            # NEW FILE - State backend
├── policies/
│   ├── security.rego             # NEW FILE - Security policies
│   ├── cost-optimization.rego    # NEW FILE - Cost policies
│   ├── compliance.rego           # NEW FILE - Compliance policies
│   └── governance.rego           # NEW FILE - Governance policies
└── scripts/
    ├── plan.sh                   # NEW FILE - Terraform planning
    ├── apply.sh                  # NEW FILE - Infrastructure deployment
    ├── destroy.sh                # NEW FILE - Infrastructure cleanup
    └── drift-check.sh            # NEW FILE - Drift detection

helm-charts/
├── planner-stack/
│   ├── Chart.yaml                # NEW FILE - Chart metadata
│   ├── values.yaml               # NEW FILE - Default values
│   ├── values-dev.yaml           # NEW FILE - Development values
│   ├── values-staging.yaml       # NEW FILE - Staging values
│   ├── values-prod.yaml          # NEW FILE - Production values
│   ├── templates/
│   │   ├── deployment.yaml       # NEW FILE - Deployment templates
│   │   ├── service.yaml          # NEW FILE - Service templates
│   │   ├── ingress.yaml          # NEW FILE - Ingress templates
│   │   ├── configmap.yaml        # NEW FILE - Configuration templates
│   │   ├── secrets.yaml          # NEW FILE - Secrets templates
│   │   ├── hpa.yaml              # NEW FILE - Autoscaler templates
│   │   └── pdb.yaml              # NEW FILE - Disruption budget
│   ├── charts/
│   │   ├── postgresql/           # NEW DIR - Database subchart
│   │   ├── redis/                # NEW DIR - Redis subchart
│   │   └── monitoring/           # NEW DIR - Monitoring subchart
│   └── tests/
│       ├── deployment_test.yaml  # NEW FILE - Chart tests
│       └── service_test.yaml     # NEW FILE - Service tests
├── microservices/
│   ├── teams-bot/
│   │   ├── Chart.yaml            # NEW FILE - Teams bot chart
│   │   ├── values.yaml           # NEW FILE - Bot configuration
│   │   └── templates/            # NEW DIR - Bot templates
│   ├── openwebui/
│   │   ├── Chart.yaml            # NEW FILE - OpenWebUI chart
│   │   ├── values.yaml           # NEW FILE - UI configuration
│   │   └── templates/            # NEW DIR - UI templates
│   ├── mcp-server/
│   │   ├── Chart.yaml            # NEW FILE - MCP server chart
│   │   ├── values.yaml           # NEW FILE - Server configuration
│   │   └── templates/            # NEW DIR - Server templates
│   └── mcpo-proxy/
│       ├── Chart.yaml            # NEW FILE - Proxy chart
│       ├── values.yaml           # NEW FILE - Proxy configuration
│       └── templates/            # NEW DIR - Proxy templates
└── infrastructure/
    ├── ingress-nginx/
    │   ├── Chart.yaml            # NEW FILE - Ingress chart
    │   └── values.yaml           # NEW FILE - Ingress config
    ├── cert-manager/
    │   ├── Chart.yaml            # NEW FILE - Cert manager chart
    │   └── values.yaml           # NEW FILE - Cert config
    └── prometheus-stack/
        ├── Chart.yaml            # NEW FILE - Monitoring chart
        └── values.yaml           # NEW FILE - Monitoring config
```

### Technical Implementation Details

**Terraform Main Configuration:**
```hcl
# terraform/environments/production/main.tf
terraform {\n  required_version = \">= 1.5\"\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n    kubernetes = {\n      source  = \"hashicorp/kubernetes\"\n      version = \"~> 2.23\"\n    }\n    helm = {\n      source  = \"hashicorp/helm\"\n      version = \"~> 2.11\"\n    }\n  }\n  \n  backend \"s3\" {\n    bucket         = \"planner-terraform-state-prod\"\n    key            = \"production/terraform.tfstate\"\n    region         = \"us-west-2\"\n    encrypt        = true\n    dynamodb_table = \"terraform-state-lock\"\n  }\n}\n\nprovider \"aws\" {\n  region = var.aws_region\n  \n  default_tags {\n    tags = {\n      Project     = \"intelligent-teams-planner\"\n      Environment = \"production\"\n      ManagedBy   = \"terraform\"\n      CostCenter  = \"engineering\"\n    }\n  }\n}\n\n# VPC and Networking\nmodule \"networking\" {\n  source = \"../../modules/networking\"\n  \n  environment         = \"production\"\n  vpc_cidr           = \"10.0.0.0/16\"\n  availability_zones = [\"us-west-2a\", \"us-west-2b\", \"us-west-2c\"]\n  \n  enable_nat_gateway = true\n  enable_vpn_gateway = false\n  \n  tags = local.common_tags\n}\n\n# Kubernetes Cluster\nmodule \"kubernetes_cluster\" {\n  source = \"../../modules/compute\"\n  \n  cluster_name    = \"planner-prod\"\n  cluster_version = \"1.28\"\n  \n  vpc_id              = module.networking.vpc_id\n  private_subnet_ids  = module.networking.private_subnet_ids\n  \n  node_groups = {\n    general = {\n      instance_types = [\"t3.large\"]\n      capacity_type  = \"ON_DEMAND\"\n      min_size      = 3\n      max_size      = 10\n      desired_size  = 5\n    }\n    \n    compute_optimized = {\n      instance_types = [\"c5.xlarge\"]\n      capacity_type  = \"SPOT\"\n      min_size      = 0\n      max_size      = 20\n      desired_size  = 2\n      \n      taints = [\n        {\n          key    = \"compute-optimized\"\n          value  = \"true\"\n          effect = \"NO_SCHEDULE\"\n        }\n      ]\n    }\n  }\n  \n  tags = local.common_tags\n}\n\n# Database Infrastructure\nmodule \"database\" {\n  source = \"../../modules/storage\"\n  \n  environment = \"production\"\n  \n  postgresql_config = {\n    engine_version    = \"15.4\"\n    instance_class   = \"db.r6g.large\"\n    allocated_storage = 100\n    max_allocated_storage = 1000\n    multi_az         = true\n    backup_retention = 30\n    \n    vpc_id             = module.networking.vpc_id\n    database_subnet_ids = module.networking.database_subnet_ids\n  }\n  \n  redis_config = {\n    node_type           = \"cache.r6g.large\"\n    num_cache_clusters  = 2\n    parameter_group     = \"default.redis7\"\n    port               = 6379\n    \n    subnet_group_name = module.networking.cache_subnet_group_name\n  }\n  \n  tags = local.common_tags\n}\n\n# Monitoring Infrastructure\nmodule \"monitoring\" {\n  source = \"../../modules/monitoring\"\n  \n  environment = \"production\"\n  \n  prometheus_config = {\n    storage_size = \"100Gi\"\n    retention    = \"30d\"\n  }\n  \n  grafana_config = {\n    admin_password = var.grafana_admin_password\n    domain        = \"grafana.planner.example.com\"\n  }\n  \n  alertmanager_config = {\n    slack_webhook_url = var.slack_webhook_url\n    email_smtp_host  = var.email_smtp_host\n  }\n  \n  tags = local.common_tags\n}\n\nlocals {\n  common_tags = {\n    Project     = \"intelligent-teams-planner\"\n    Environment = \"production\"\n    ManagedBy   = \"terraform\"\n    CostCenter  = \"engineering\"\n  }\n}\n```\n\n**Helm Chart Configuration:**\n```yaml\n# helm-charts/planner-stack/Chart.yaml\napiVersion: v2\nname: planner-stack\ndescription: Intelligent Teams Planner complete application stack\ntype: application\nversion: 1.0.0\nappVersion: \"2.0.0\"\n\nkeywords:\n  - planner\n  - teams\n  - ai\n  - microsoft\n\nhome: https://github.com/intelligent-teams-planner\nsources:\n  - https://github.com/intelligent-teams-planner\n\nmaintainers:\n  - name: BMad Framework\n    email: engineering@example.com\n\ndependencies:\n  - name: postgresql\n    version: \"12.10.0\"\n    repository: \"https://charts.bitnami.com/bitnami\"\n    condition: postgresql.enabled\n  \n  - name: redis\n    version: \"18.1.5\"\n    repository: \"https://charts.bitnami.com/bitnami\"\n    condition: redis.enabled\n  \n  - name: prometheus\n    version: \"25.3.1\"\n    repository: \"https://prometheus-community.github.io/helm-charts\"\n    condition: monitoring.prometheus.enabled\n  \n  - name: grafana\n    version: \"7.0.3\"\n    repository: \"https://grafana.github.io/helm-charts\"\n    condition: monitoring.grafana.enabled\n---\n# helm-charts/planner-stack/values.yaml\nglobal:\n  imageRegistry: ghcr.io\n  imagePullSecrets:\n    - name: ghcr-secret\n  \n  storageClass: \"gp3-ssd\"\n  \n  labels:\n    app.kubernetes.io/name: planner-stack\n    app.kubernetes.io/instance: production\n    app.kubernetes.io/version: \"2.0.0\"\n    app.kubernetes.io/managed-by: helm\n\nteamsBot:\n  enabled: true\n  image:\n    repository: intelligent-teams-planner/teams-bot\n    tag: \"latest\"\n    pullPolicy: Always\n  \n  replicaCount: 3\n  \n  resources:\n    requests:\n      memory: \"256Mi\"\n      cpu: \"100m\"\n    limits:\n      memory: \"512Mi\"\n      cpu: \"250m\"\n  \n  autoscaling:\n    enabled: true\n    minReplicas: 3\n    maxReplicas: 20\n    targetCPUUtilization: 70\n    targetMemoryUtilization: 80\n  \n  service:\n    type: ClusterIP\n    port: 3978\n  \n  ingress:\n    enabled: true\n    className: nginx\n    annotations:\n      cert-manager.io/cluster-issuer: letsencrypt-prod\n      nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n    hosts:\n      - host: teams-bot.planner.example.com\n        paths:\n          - path: /\n            pathType: Prefix\n    tls:\n      - secretName: teams-bot-tls\n        hosts:\n          - teams-bot.planner.example.com\n\nopenwebui:\n  enabled: true\n  image:\n    repository: ghcr.io/open-webui/open-webui\n    tag: \"main\"\n    pullPolicy: Always\n  \n  replicaCount: 2\n  \n  resources:\n    requests:\n      memory: \"1Gi\"\n      cpu: \"500m\"\n    limits:\n      memory: \"2Gi\"\n      cpu: \"1000m\"\n  \n  service:\n    type: ClusterIP\n    port: 8080\n  \n  ingress:\n    enabled: true\n    className: nginx\n    annotations:\n      cert-manager.io/cluster-issuer: letsencrypt-prod\n      nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n      nginx.ingress.kubernetes.io/proxy-body-size: \"100m\"\n    hosts:\n      - host: planner.example.com\n        paths:\n          - path: /\n            pathType: Prefix\n    tls:\n      - secretName: openwebui-tls\n        hosts:\n          - planner.example.com\n\nmcpServer:\n  enabled: true\n  image:\n    repository: intelligent-teams-planner/mcp-server\n    tag: \"latest\"\n    pullPolicy: Always\n  \n  replicaCount: 3\n  \n  resources:\n    requests:\n      memory: \"512Mi\"\n      cpu: \"250m\"\n    limits:\n      memory: \"1Gi\"\n      cpu: \"500m\"\n  \n  autoscaling:\n    enabled: true\n    minReplicas: 3\n    maxReplicas: 15\n    targetCPUUtilization: 70\n  \n  service:\n    type: ClusterIP\n    port: 8000\n\nmcpoProxy:\n  enabled: true\n  image:\n    repository: intelligent-teams-planner/mcpo-proxy\n    tag: \"latest\"\n    pullPolicy: Always\n  \n  replicaCount: 2\n  \n  resources:\n    requests:\n      memory: \"256Mi\"\n      cpu: \"100m\"\n    limits:\n      memory: \"512Mi\"\n      cpu: \"250m\"\n  \n  service:\n    type: ClusterIP\n    port: 8001\n\npostgresql:\n  enabled: true\n  auth:\n    enablePostgresUser: true\n    postgresPassword: \"changeme\"\n    database: \"planner\"\n  \n  architecture: replication\n  \n  primary:\n    persistence:\n      enabled: true\n      size: 100Gi\n      storageClass: \"gp3-ssd\"\n    \n    resources:\n      requests:\n        memory: \"1Gi\"\n        cpu: \"500m\"\n      limits:\n        memory: \"2Gi\"\n        cpu: \"1000m\"\n  \n  readReplicas:\n    replicaCount: 2\n    persistence:\n      enabled: true\n      size: 100Gi\n    \n    resources:\n      requests:\n        memory: \"1Gi\"\n        cpu: \"250m\"\n      limits:\n        memory: \"2Gi\"\n        cpu: \"500m\"\n\nredis:\n  enabled: true\n  architecture: replication\n  auth:\n    enabled: true\n    password: \"changeme\"\n  \n  master:\n    persistence:\n      enabled: true\n      size: 20Gi\n      storageClass: \"gp3-ssd\"\n    \n    resources:\n      requests:\n        memory: \"512Mi\"\n        cpu: \"250m\"\n      limits:\n        memory: \"1Gi\"\n        cpu: \"500m\"\n  \n  replica:\n    replicaCount: 2\n    persistence:\n      enabled: true\n      size: 20Gi\n    \n    resources:\n      requests:\n        memory: \"512Mi\"\n        cpu: \"125m\"\n      limits:\n        memory: \"1Gi\"\n        cpu: \"250m\"\n\nmonitoring:\n  prometheus:\n    enabled: true\n    server:\n      retention: \"30d\"\n      persistentVolume:\n        size: 100Gi\n        storageClass: \"gp3-ssd\"\n      \n      resources:\n        requests:\n          memory: \"2Gi\"\n          cpu: \"500m\"\n        limits:\n          memory: \"4Gi\"\n          cpu: \"1000m\"\n  \n  grafana:\n    enabled: true\n    adminPassword: \"changeme\"\n    \n    persistence:\n      enabled: true\n      size: 10Gi\n      storageClass: \"gp3-ssd\"\n    \n    ingress:\n      enabled: true\n      annotations:\n        cert-manager.io/cluster-issuer: letsencrypt-prod\n      hosts:\n        - grafana.planner.example.com\n      tls:\n        - secretName: grafana-tls\n          hosts:\n            - grafana.planner.example.com\n```\n\n### Environment Variables (Infrastructure Configuration)\n\n```env\n# Terraform Configuration\nTF_VAR_aws_region=us-west-2\nTF_VAR_environment=production\nTF_VAR_project_name=intelligent-teams-planner\n\n# Database Configuration\nTF_VAR_postgresql_instance_class=db.r6g.large\nTF_VAR_postgresql_allocated_storage=100\nTF_VAR_postgresql_max_allocated_storage=1000\nTF_VAR_postgresql_backup_retention=30\nTF_VAR_postgresql_multi_az=true\n\n# Redis Configuration\nTF_VAR_redis_node_type=cache.r6g.large\nTF_VAR_redis_num_cache_clusters=2\nTF_VAR_redis_parameter_group=default.redis7\n\n# Kubernetes Configuration\nTF_VAR_kubernetes_version=1.28\nTF_VAR_node_group_instance_types=[\"t3.large\"]\nTF_VAR_node_group_min_size=3\nTF_VAR_node_group_max_size=10\nTF_VAR_node_group_desired_size=5\n\n# Monitoring Configuration\nTF_VAR_prometheus_storage_size=100Gi\nTF_VAR_prometheus_retention=30d\nTF_VAR_grafana_admin_password=${GRAFANA_ADMIN_PASSWORD}\n\n# Alerting Configuration\nTF_VAR_slack_webhook_url=${SLACK_WEBHOOK_URL}\nTF_VAR_email_smtp_host=${EMAIL_SMTP_HOST}\n\n# Security Configuration\nTF_VAR_enable_encryption=true\nTF_VAR_enable_backup=true\nTF_VAR_backup_retention_days=30\n\n# Cost Optimization\nTF_VAR_enable_spot_instances=true\nTF_VAR_spot_instance_percentage=50\nTF_VAR_enable_scheduled_scaling=true\n\n# Helm Configuration\nHELM_REGISTRY_URL=ghcr.io\nHELM_REGISTRY_USERNAME=${GITHUB_ACTOR}\nHELM_REGISTRY_PASSWORD=${GITHUB_TOKEN}\n\n# Chart Configuration\nCHART_VERSION=1.0.0\nAPP_VERSION=2.0.0\nIMAGE_TAG=latest\n\n# Environment Specific\nENVIRONMENT=production\nNAMESPACE=production\nCLUSTER_NAME=planner-prod\nDOMAIN=planner.example.com\n```\n\n### Policy as Code Configuration\n\n**Security Policy (OPA Rego):**\n```rego\n# terraform/policies/security.rego\npackage terraform.security\n\nimport rego.v1\n\n# Deny unencrypted storage\ndeny contains msg if {\n    input.resource_changes[_].type == \"aws_s3_bucket\"\n    not input.resource_changes[_].change.after.server_side_encryption_configuration\n    msg := \"S3 buckets must have server-side encryption enabled\"\n}\n\n# Deny public read access\ndeny contains msg if {\n    input.resource_changes[_].type == \"aws_s3_bucket_public_access_block\"\n    input.resource_changes[_].change.after.block_public_read_policy == false\n    msg := \"S3 buckets must block public read access\"\n}\n\n# Require VPC for RDS instances\ndeny contains msg if {\n    input.resource_changes[_].type == \"aws_db_instance\"\n    not input.resource_changes[_].change.after.db_subnet_group_name\n    msg := \"RDS instances must be deployed in a VPC\"\n}\n\n# Require multi-AZ for production databases\ndeny contains msg if {\n    input.resource_changes[_].type == \"aws_db_instance\"\n    input.resource_changes[_].change.after.tags.Environment == \"production\"\n    input.resource_changes[_].change.after.multi_az != true\n    msg := \"Production RDS instances must have multi-AZ enabled\"\n}\n\n# Require backup retention for databases\ndeny contains msg if {\n    input.resource_changes[_].type == \"aws_db_instance\"\n    input.resource_changes[_].change.after.backup_retention_period < 7\n    msg := \"RDS instances must have at least 7 days backup retention\"\n}\n```\n\n**Cost Optimization Policy:**\n```rego\n# terraform/policies/cost-optimization.rego\npackage terraform.cost\n\nimport rego.v1\n\n# Warn about expensive instance types\nwarn contains msg if {\n    input.resource_changes[_].type == \"aws_instance\"\n    instance_type := input.resource_changes[_].change.after.instance_type\n    startswith(instance_type, \"r5.\")\n    contains(instance_type, \"large\")\n    msg := sprintf(\"Consider using smaller instance type instead of %s\", [instance_type])\n}\n\n# Require tagging for cost allocation\ndeny contains msg if {\n    input.resource_changes[_].type in [\n        \"aws_instance\",\n        \"aws_db_instance\",\n        \"aws_elasticache_cluster\"\n    ]\n    not input.resource_changes[_].change.after.tags.CostCenter\n    msg := \"Resources must have CostCenter tag for cost allocation\"\n}\n\n# Warn about unused security groups\nwarn contains msg if {\n    input.resource_changes[_].type == \"aws_security_group\"\n    count(input.resource_changes[_].change.after.ingress) == 0\n    count(input.resource_changes[_].change.after.egress) == 0\n    msg := \"Security group appears to be unused (no ingress/egress rules)\"\n}\n```\n\n### Testing Strategy\n\n**Infrastructure Testing Framework:**\n- Terratest for Terraform module testing\n- Helm unittest for chart validation\n- Open Policy Agent testing for policy validation\n- Inspec for infrastructure compliance testing\n\n**Terraform Testing:**\n```go\n// terraform/test/infrastructure_test.go\npackage test\n\nimport (\n    \"testing\"\n    \"github.com/gruntwork-io/terratest/modules/terraform\"\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTerraformInfrastructure(t *testing.T) {\n    terraformOptions := &terraform.Options{\n        TerraformDir: \"../environments/test\",\n        Vars: map[string]interface{}{\n            \"environment\": \"test\",\n            \"vpc_cidr\": \"10.1.0.0/16\",\n        },\n    }\n    \n    defer terraform.Destroy(t, terraformOptions)\n    terraform.InitAndApply(t, terraformOptions)\n    \n    // Validate VPC creation\n    vpcId := terraform.Output(t, terraformOptions, \"vpc_id\")\n    assert.NotEmpty(t, vpcId)\n    \n    // Validate subnets\n    privateSubnets := terraform.OutputList(t, terraformOptions, \"private_subnet_ids\")\n    assert.Len(t, privateSubnets, 3)\n    \n    // Validate Kubernetes cluster\n    clusterName := terraform.Output(t, terraformOptions, \"cluster_name\")\n    assert.Equal(t, \"planner-test\", clusterName)\n}\n```\n\n**Helm Chart Testing:**\n```yaml\n# helm-charts/planner-stack/tests/deployment_test.yaml\nsuite: test deployment\ntests:\n  - it: should create deployment with correct image\n    template: templates/deployment.yaml\n    set:\n      mcpServer.image.repository: test-repo\n      mcpServer.image.tag: test-tag\n    asserts:\n      - isKind:\n          of: Deployment\n      - equal:\n          path: spec.template.spec.containers[0].image\n          value: test-repo:test-tag\n  \n  - it: should set resource limits\n    template: templates/deployment.yaml\n    asserts:\n      - isNotEmpty:\n          path: spec.template.spec.containers[0].resources.limits\n      - isNotEmpty:\n          path: spec.template.spec.containers[0].resources.requests\n  \n  - it: should create HPA when autoscaling enabled\n    template: templates/hpa.yaml\n    set:\n      mcpServer.autoscaling.enabled: true\n    asserts:\n      - isKind:\n          of: HorizontalPodAutoscaler\n      - equal:\n          path: spec.minReplicas\n          value: 3\n```\n\n### Monitoring and Drift Detection\n\n**Drift Detection Script:**\n```bash\n#!/bin/bash\n# terraform/scripts/drift-check.sh\n\nset -e\n\nENVIRONMENT=${1:-production}\nWORKSPACE=\"terraform/environments/$ENVIRONMENT\"\n\necho \"Checking for drift in $ENVIRONMENT environment...\"\n\ncd \"$WORKSPACE\"\n\n# Initialize Terraform\nterraform init -backend=true\n\n# Check for drift\nif terraform plan -detailed-exitcode -out=tfplan; then\n    PLAN_EXIT_CODE=$?\nelse\n    PLAN_EXIT_CODE=$?\nfi\n\ncase $PLAN_EXIT_CODE in\n    0)\n        echo \"No changes detected - infrastructure is in sync\"\n        ;;\n    1)\n        echo \"Error occurred during planning\"\n        exit 1\n        ;;\n    2)\n        echo \"Drift detected - infrastructure changes required\"\n        terraform show tfplan\n        \n        # Send alert\n        if [ \"$AUTO_CORRECT_DRIFT\" = \"true\" ]; then\n            echo \"Auto-correcting drift...\"\n            terraform apply tfplan\n        else\n            echo \"Manual review required for drift correction\"\n            # Send notification\n            curl -X POST \"$SLACK_WEBHOOK_URL\" \\\n                -H 'Content-type: application/json' \\\n                --data '{\"text\":\"Infrastructure drift detected in '\"$ENVIRONMENT\"' environment. Manual review required.\"}'\n        fi\n        ;;\nesac\n\n# Cleanup\nrm -f tfplan\n```\n\n**Compliance Monitoring:**\n```bash\n#!/bin/bash\n# terraform/scripts/compliance-check.sh\n\nset -e\n\nENVIRONMENT=${1:-production}\nWORKSPACE=\"terraform/environments/$ENVIRONMENT\"\n\necho \"Running compliance checks for $ENVIRONMENT environment...\"\n\ncd \"$WORKSPACE\"\n\n# Run Terraform plan\nterraform plan -out=tfplan.binary\nterraform show -json tfplan.binary > tfplan.json\n\n# Run OPA policy checks\necho \"Checking security policies...\"\nopa eval -d ../../policies/security.rego -I tfplan.json \"data.terraform.security.deny[x]\"\n\necho \"Checking cost optimization policies...\"\nopa eval -d ../../policies/cost-optimization.rego -I tfplan.json \"data.terraform.cost.warn[x]\"\n\necho \"Checking compliance policies...\"\nopa eval -d ../../policies/compliance.rego -I tfplan.json \"data.terraform.compliance.deny[x]\"\n\n# Run infrastructure tests\necho \"Running infrastructure compliance tests...\"\ninspec exec ../../tests/compliance/ -t aws://\n\necho \"Compliance check completed\"\n\n# Cleanup\nrm -f tfplan.binary tfplan.json\n```\n\n## Change Log\n\n| Date | Version | Description | Author |\n|------|---------|-------------|--------|\n| 2025-10-06 | 1.0 | Initial infrastructure as code story | BMad Framework |\n\n## Dev Agent Record\n\n*This section will be populated by the development agent during implementation*\n\n### Agent Model Used\n*{{agent_model_name_version}}*\n\n### Debug Log References\n*Reference any debug logs or traces generated during development*\n\n### Completion Notes List\n*Notes about the completion of tasks and any issues encountered*\n\n### File List\n*List all files created, modified, or affected during story implementation*\n\n## QA Results\n\n*Results from QA Agent QA review of the completed story implementation*